"""
Data models for seclog.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional


class Severity(Enum):
    """Alert severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

    @classmethod
    def from_string(cls, value: str) -> "Severity":
        """Convert string to Severity, case-insensitive."""
        try:
            return cls(value.lower())
        except ValueError:
            return cls.INFO


@dataclass
class LogEntry:
    """Unified log entry structure after parsing."""
    timestamp: datetime
    source_ip: str
    action: str
    severity: str = "info"
    raw_message: str = ""
    path: Optional[str] = None
    method: Optional[str] = None
    status: Optional[int] = None
    user_agent: Optional[str] = None
    extra: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "source_ip": self.source_ip,
            "action": self.action,
            "severity": self.severity,
            "raw_message": self.raw_message,
            "path": self.path,
            "method": self.method,
            "status": self.status,
            "user_agent": self.user_agent,
            "extra": self.extra,
        }


@dataclass
class Rule:
    """Security detection rule."""
    name: str
    description: str
    severity: str
    type: str  # "single" or "aggregate"
    pattern: Optional[str] = None
    field: str = "raw_message"
    threshold: Optional[int] = None
    timewindow: Optional[int] = None

    def validate(self) -> List[str]:
        """Validate rule configuration. Returns list of errors."""
        errors = []
        if not self.name:
            errors.append("Rule must have a name")
        if self.severity not in [s.value for s in Severity]:
            errors.append(f"Invalid severity: {self.severity}")
        if self.type == "single":
            if not self.pattern:
                errors.append("Single rule must have a pattern")
        elif self.type == "aggregate":
            if not self.threshold:
                errors.append("Aggregate rule must have threshold")
            if not self.timewindow:
                errors.append("Aggregate rule must have timewindow")
        else:
            errors.append(f"Invalid rule type: {self.type}")
        return errors


@dataclass
class Alert:
    """Security alert generated by the analyzer."""
    rule_name: str
    severity: str
    timestamp: datetime
    source_ip: str
    matched_log: str
    description: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "rule_name": self.rule_name,
            "severity": self.severity,
            "timestamp": self.timestamp.isoformat(),
            "source_ip": self.source_ip,
            "matched_log": self.matched_log,
            "description": self.description,
        }


@dataclass
class AnalysisResult:
    """Result of log analysis."""
    total_logs: int = 0
    alerts: List[Alert] = field(default_factory=list)

    def count_by_severity(self) -> Dict[str, int]:
        """Count alerts by severity level."""
        counts = {s.value: 0 for s in Severity if s.value != "info"}
        for alert in self.alerts:
            if alert.severity in counts:
                counts[alert.severity] += 1
        return counts

    def top_source_ips(self, limit: int = 10) -> List[tuple]:
        """Get top source IPs by alert count."""
        ip_counts: Dict[str, int] = {}
        for alert in self.alerts:
            ip_counts[alert.source_ip] = ip_counts.get(alert.source_ip, 0) + 1
        return sorted(ip_counts.items(), key=lambda x: x[1], reverse=True)[:limit]

    def alerts_by_hour(self) -> Dict[int, int]:
        """Get alert distribution by hour."""
        hourly: Dict[int, int] = {h: 0 for h in range(24)}
        for alert in self.alerts:
            hourly[alert.timestamp.hour] += 1
        return hourly

    def rule_hit_stats(self) -> Dict[str, int]:
        """Get rule hit statistics."""
        stats: Dict[str, int] = {}
        for alert in self.alerts:
            stats[alert.rule_name] = stats.get(alert.rule_name, 0) + 1
        return dict(sorted(stats.items(), key=lambda x: x[1], reverse=True))
